
main.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000d28  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000018  40000000  40000000  00010000  2**2
                  ALLOC
  2 .stack        00000a00  40000018  40000018  00008d28  2**3
                  CONTENTS
  3 .ARM.attributes 00000030  00000000  00000000  00009728  2**0
                  CONTENTS, READONLY
  4 .comment      0000002a  00000000  00000000  00009758  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 000001c8  00000000  00000000  00009788  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000268  00000000  00000000  00009950  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000014fd  00000000  00000000  00009bb8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000544  00000000  00000000  0000b0b5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000763  00000000  00000000  0000b5f9  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000340  00000000  00000000  0000bd5c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000006d7  00000000  00000000  0000c09c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000798  00000000  00000000  0000c773  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000170  00000000  00000000  0000cf10  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_pubtypes 0000018f  00000000  00000000  0000d080  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <Trap-0x3c>:
@-----------------------------------------------------------@

.section .VECTOR, "ax"
.arm

	LDR	PC, [PC, #24]	@ Reset entry, jump to reset handler
   0:	e59ff018 	ldr	pc, [pc, #24]	; 20 <B_Thumb>
	LDR	PC, [PC, #24]	@ Undef entry, trap
   4:	e59ff018 	ldr	pc, [pc, #24]	; 24 <VIC_SWPriorityMask>
	LDR	PC, [PC, #24]	@ SWI entry, jump to SWI handler
   8:	e59ff018 	ldr	pc, [pc, #24]	; 28 <VIC_SWPriorityMask+0x4>
	LDR	PC, [PC, #24]	@ PAbt entry, trap
   c:	e59ff018 	ldr	pc, [pc, #24]	; 2c <VIC_SWPriorityMask+0x8>
	LDR	PC, [PC, #24]	@ DAbt entry, trap
  10:	e59ff018 	ldr	pc, [pc, #24]	; 30 <VIC_SWPriorityMask+0xc>
  14:	00000000 	.word	0x00000000
	.word	0
	LDR	PC, [PC, #20]	@ IRQ entry, jump to IRQ handler
  18:	e59ff014 	ldr	pc, [pc, #20]	; 34 <VIC_SWPriorityMask+0x10>
	LDR     PC, [PC, #20]	@ FIQ entry, trap
  1c:	e59ff014 	ldr	pc, [pc, #20]	; 38 <VIC_SWPriorityMask+0x14>
  20:	00000040 	.word	0x00000040
  24:	0000003c 	.word	0x0000003c
  28:	00000124 	.word	0x00000124
  2c:	0000003c 	.word	0x0000003c
  30:	0000003c 	.word	0x0000003c
  34:	000000e0 	.word	0x000000e0
  38:	0000003c 	.word	0x0000003c

0000003c <Trap>:
	.word	Trap		@ Prefetch Abort handler
	.word	Trap		@ Data Abort handler
	.word	IRQ_Handler	@ IRQ handler
	.word	Trap		@ FIQ handler

Trap:	B	Trap		@ Unused exception trap (infinite loop)
  3c:	eafffffe 	b	3c <Trap>

00000040 <Reset_Handler>:
@	LDR	R0, =TargetResetInit
@	MOV	LR, PC
@	BX	R0

@ Setup Stack for each mode
	LDR	R0, =Stack_Top
  40:	e59f0360 	ldr	r0, [pc, #864]	; 3a8 <sb_align+0x18>

@ Enter Undefined Instruction Mode and set its Stack Pointer
	MSR	CPSR_c, #M_UND | B_Irq | B_Fiq
  44:	e321f0db 	msr	CPSR_c, #219	; 0xdb
	MOV	SP, R0
  48:	e1a0d000 	mov	sp, r0
	SUB	R0, R0, #UND_Stack_Size
  4c:	e2400000 	sub	r0, r0, #0

@ Enter Abort Mode and set its Stack Pointer
	MSR	CPSR_c, #M_ABT | B_Irq | B_Fiq
  50:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
	MOV	SP, R0
  54:	e1a0d000 	mov	sp, r0
	SUB	R0, R0, #ABT_Stack_Size
  58:	e2400000 	sub	r0, r0, #0

@ Enter FIQ Mode and set its Stack Pointer
	MSR	CPSR_c, #M_FIQ | B_Irq | B_Fiq
  5c:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
	MOV	SP, R0
  60:	e1a0d000 	mov	sp, r0
	SUB	R0, R0, #FIQ_Stack_Size
  64:	e2400000 	sub	r0, r0, #0

@ Enter IRQ Mode and set its Stack Pointer
	MSR	CPSR_c, #M_IRQ | B_Irq | B_Fiq
  68:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
	MOV	SP, R0
  6c:	e1a0d000 	mov	sp, r0
	SUB	R0, R0, #IRQ_Stack_Size
  70:	e2400c01 	sub	r0, r0, #256	; 0x100

@ Enter Supervisor Mode and set its Stack Pointer
	MSR	CPSR_c, #M_SVC | B_Irq | B_Fiq
  74:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
	MOV	SP, R0
  78:	e1a0d000 	mov	sp, r0
	SUB	R0, R0, #SVC_Stack_Size
  7c:	e2400c01 	sub	r0, r0, #256	; 0x100

@ Enter User Mode and set its Stack Pointer
	MSR	CPSR_c, #M_USR | B_Irq | B_Fiq
  80:	e321f0d0 	msr	CPSR_c, #208	; 0xd0
	MOV	SP, R0
  84:	e1a0d000 	mov	sp, r0
	SUB	SL, SP, #USR_Stack_Size
  88:	e24dab02 	sub	sl, sp, #2048	; 0x800

@ Relocate .data section (Initialize with ROM data)
	LDR	R1, =_etext
  8c:	e59f1318 	ldr	r1, [pc, #792]	; 3ac <sb_align+0x1c>
	LDR	R2, =_data
  90:	e59f2318 	ldr	r2, [pc, #792]	; 3b0 <sb_align+0x20>
	LDR	R3, =_edata
  94:	e59f3318 	ldr	r3, [pc, #792]	; 3b4 <sb_align+0x24>
	CMP	R2, R3
  98:	e1520003 	cmp	r2, r3
	BEQ	DataIsEmpty
  9c:	0a000003 	beq	b0 <DataIsEmpty>

000000a0 <LoopRel>:
LoopRel:CMP	R2, R3
  a0:	e1520003 	cmp	r2, r3
	LDRLO	R0, [R1], #4
  a4:	34910004 	ldrcc	r0, [r1], #4
	STRLO	R0, [R2], #4
  a8:	34820004 	strcc	r0, [r2], #4
	BLO	LoopRel
  ac:	3afffffb 	bcc	a0 <LoopRel>

000000b0 <DataIsEmpty>:
DataIsEmpty:

@ Clear .bss section (Initialize with 0)
	MOV	R0, #0
  b0:	e3a00000 	mov	r0, #0
	LDR	R1, =__bss_start__
  b4:	e59f12fc 	ldr	r1, [pc, #764]	; 3b8 <sb_align+0x28>
	LDR	R2, =__bss_end__
  b8:	e59f22fc 	ldr	r2, [pc, #764]	; 3bc <sb_align+0x2c>
	CMP	R1,R2
  bc:	e1510002 	cmp	r1, r2
	BEQ	BSSIsEmpty
  c0:	0a000002 	beq	d0 <BSSIsEmpty>

000000c4 <LoopZI>:
LoopZI:	CMP	R1, R2
  c4:	e1510002 	cmp	r1, r2
	STRLO	R0, [R1], #4
  c8:	34810004 	strcc	r0, [r1], #4
	BLO	LoopZI
  cc:	3afffffc 	bcc	c4 <LoopZI>

000000d0 <BSSIsEmpty>:
BSSIsEmpty:

@ Start main()
.extern main
	LDR	R0, =main
  d0:	e59f02e8 	ldr	r0, [pc, #744]	; 3c0 <sb_align+0x30>
	MOV	LR, PC
  d4:	e1a0e00f 	mov	lr, pc
	BX	R0
  d8:	e12fff10 	bx	r0

000000dc <MTrap>:
MTrap:	B	MTrap	@ Trap if main() terminated
  dc:	eafffffe 	b	dc <MTrap>

000000e0 <IRQ_Handler>:
.equ VIC_VectAddr,	0xF00

.section .text, "ax"
.arm
IRQ_Handler:
	SUB	LR, LR, #4		@ Adjust LR_irq and push it
  e0:	e24ee004 	sub	lr, lr, #4
	STMFD	SP!, {LR}
  e4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)

	MRS	LR, SPSR		@ Save SPSR need to be saved for nested interrupt
  e8:	e14fe000 	mrs	lr, SPSR
	STMFD	SP!, {R0-R3,IP,LR}	@ Push scratch/used registers and SPSR
  ec:	e92d500f 	push	{r0, r1, r2, r3, ip, lr}
	LDR	R0, =LPC_BASE_VIC	@ Get the ISR address pointed by VIC_VectAddr
  f0:	e59f02cc 	ldr	r0, [pc, #716]	; 3c4 <sb_align+0x34>
	LDR	R0, [R0, #VIC_VectAddr]
  f4:	e5900f00 	ldr	r0, [r0, #3840]	; 0xf00
	MSR	CPSR_c, #M_SVC		@ Enter SVC mode and enable Irq and Fiq
  f8:	e321f013 	msr	CPSR_c, #19

	STMFD	SP!, {LR}		@ Call the ISR
  fc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	MOV	LR, PC
 100:	e1a0e00f 	mov	lr, pc
	BX	R0
 104:	e12fff10 	bx	r0
	LDMIA	SP!, {LR}
 108:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)

	MSR	CPSR_c, #M_IRQ | B_Irq	@ Enter IRQ mode and disable Irq
 10c:	e321f092 	msr	CPSR_c, #146	; 0x92
	LDMIA	SP!, {R0-R3,IP,LR}	@ Restore scratch/used registers and SPSR
 110:	e8bd500f 	pop	{r0, r1, r2, r3, ip, lr}
	MSR	SPSR_cxsf, LR		@ Restore SPSR_irq
 114:	e16ff00e 	msr	SPSR_fsxc, lr

	LDR	LR, =LPC_BASE_VIC	@ Issue EOI command to the VIC
 118:	e59fe2a4 	ldr	lr, [pc, #676]	; 3c4 <sb_align+0x34>
	STR	LR, [LR, #VIC_VectAddr]
 11c:	e58eef00 	str	lr, [lr, #3840]	; 0xf00

	LDMIA	SP!, {PC}^		@ Reruen from the IRQ handler
 120:	e8fd8000 	ldm	sp!, {pc}^

00000124 <SWI_Handler>:


.section .text, "ax"
.arm
SWI_Handler:
	LDR	IP, [LR, #-4]		@ Get swi instruction code (assuming ARM state)
 124:	e51ec004 	ldr	ip, [lr, #-4]
	AND	IP, #0xFF		@ Get swi comment field (lower 8 bit)
 128:	e20cc0ff 	and	ip, ip, #255	; 0xff
	CMP	IP, #NUM_SWIs		@ Check range
 12c:	e35c0006 	cmp	ip, #6
	LDRLO	PC, [PC, IP, LSL #2]	@ Jump each service function when code is valid
 130:	379ff10c 	ldrcc	pc, [pc, ip, lsl #2]
	MOVS	PC, LR			@ Otherwise return
 134:	e1b0f00e 	movs	pc, lr
 138:	00000150 	.word	0x00000150
 13c:	00000160 	.word	0x00000160
 140:	00000170 	.word	0x00000170
 144:	00000180 	.word	0x00000180
 148:	00000190 	.word	0x00000190
 14c:	000001b4 	.word	0x000001b4

00000150 <IRQDisable>:
	.word	FIQEnable
	.word	ClearVect
	.word	RegVect

IRQDisable:
	MRS	R0, SPSR
 150:	e14f0000 	mrs	r0, SPSR
	ORR	R0, R0, #B_Irq
 154:	e3800080 	orr	r0, r0, #128	; 0x80
	MSR	SPSR_c, R0
 158:	e161f000 	msr	SPSR_c, r0
	MOVS	PC, LR
 15c:	e1b0f00e 	movs	pc, lr

00000160 <IRQEnable>:

IRQEnable:
	MRS	R0, SPSR
 160:	e14f0000 	mrs	r0, SPSR
	BIC	R0, R0, #B_Irq
 164:	e3c00080 	bic	r0, r0, #128	; 0x80
	MSR	SPSR_c, R0
 168:	e161f000 	msr	SPSR_c, r0
	MOVS	PC, LR
 16c:	e1b0f00e 	movs	pc, lr

00000170 <FIQDisable>:

FIQDisable:
	MRS	R0, SPSR
 170:	e14f0000 	mrs	r0, SPSR
	ORR	R0, R0, #B_Fiq
 174:	e3800040 	orr	r0, r0, #64	; 0x40
	MSR	SPSR_c, R0
 178:	e161f000 	msr	SPSR_c, r0
	MOVS	PC, LR
 17c:	e1b0f00e 	movs	pc, lr

00000180 <FIQEnable>:

FIQEnable:
	MRS	R0, SPSR
 180:	e14f0000 	mrs	r0, SPSR
	BIC	R0, R0, #B_Fiq
 184:	e3c00040 	bic	r0, r0, #64	; 0x40
	MSR	SPSR_c, R0
 188:	e161f000 	msr	SPSR_c, r0
	MOVS	PC, LR
 18c:	e1b0f00e 	movs	pc, lr

00000190 <ClearVect>:

ClearVect:
	LDR	IP, =LPC_BASE_VIC
 190:	e59fc22c 	ldr	ip, [pc, #556]	; 3c4 <sb_align+0x34>
	MVN	R0, #0				@ Disable all interrupts
 194:	e3e00000 	mvn	r0, #0
	STR	R0, [IP, #VIC_IntEnClear]
 198:	e58c0014 	str	r0, [ip, #20]
	MOV	R0, R0, LSR #16			@ Unmask all interrupt levels
 19c:	e1a00820 	lsr	r0, r0, #16
	STR	R0, [IP, #VIC_SWPriorityMask]
 1a0:	e58c0024 	str	r0, [ip, #36]	; 0x24
	MOV	R0, #1				@ Enable protection
 1a4:	e3a00001 	mov	r0, #1
	STR	R0, [IP, #VIC_Protection]
 1a8:	e58c0020 	str	r0, [ip, #32]
	STR	R0, [IP, #VIC_VectAddr]		@ Issule EOI command
 1ac:	e58c0f00 	str	r0, [ip, #3840]	; 0xf00
	MOVS	PC, LR
 1b0:	e1b0f00e 	movs	pc, lr

000001b4 <RegVect>:

RegVect:
	CMP	R0, #32				@ Range check
 1b4:	e3500020 	cmp	r0, #32
	MOVCSS	PC, LR
 1b8:	21b0f00e 	movscs	pc, lr
	LDR	IP, =(LPC_BASE_VIC+VIC_VectAddr0)
 1bc:	e59fc204 	ldr	ip, [pc, #516]	; 3c8 <sb_align+0x38>
	STR	R1, [IP, R0, LSL #2]		@ Set VICVectVectAddr<n>
 1c0:	e78c1100 	str	r1, [ip, r0, lsl #2]
	LDR	IP, =(LPC_BASE_VIC+VIC_VectPriority0)
 1c4:	e59fc200 	ldr	ip, [pc, #512]	; 3cc <sb_align+0x3c>
	STR	R2, [IP, R0, LSL #2]		@ Set VICVectPriority<n>
 1c8:	e78c2100 	str	r2, [ip, r0, lsl #2]
	MOV	R1, #1
 1cc:	e3a01001 	mov	r1, #1
	MOV	R1, R1, LSL R0
 1d0:	e1a01011 	lsl	r1, r1, r0
	LDR	IP, =LPC_BASE_VIC
 1d4:	e59fc1e8 	ldr	ip, [pc, #488]	; 3c4 <sb_align+0x34>
	LDR	R2, [IP, #VIC_IntSelect]	@ Set corresponding bit in the VICIntSelect
 1d8:	e59c200c 	ldr	r2, [ip, #12]
	BIC	R2, R1
 1dc:	e1c22001 	bic	r2, r2, r1
	CMP	R3, #1
 1e0:	e3530001 	cmp	r3, #1
	ORREQ	R2, R1
 1e4:	01822001 	orreq	r2, r2, r1
	STR	R2, [IP, #VIC_IntSelect]
 1e8:	e58c200c 	str	r2, [ip, #12]
	STR	R1, [IP, #VIC_IntEnable]	@ Enable corresponding interrupt
 1ec:	e58c1010 	str	r1, [ip, #16]
	MOVS	PC, LR
 1f0:	e1b0f00e 	movs	pc, lr

000001f4 <IrqDisable>:

.global IrqDisable
IrqDisable:
	SWI	SWI_IRQ_DIS
 1f4:	ef000000 	svc	0x00000000
	BX	LR
 1f8:	e12fff1e 	bx	lr

000001fc <IrqEnable>:

.global IrqEnable
IrqEnable:
	SWI	SWI_IRQ_EN
 1fc:	ef000001 	svc	0x00000001
	BX	LR
 200:	e12fff1e 	bx	lr

00000204 <FiqDisable>:

.global FiqDisable
FiqDisable:
	SWI	SWI_FIQ_DIS
 204:	ef000002 	svc	0x00000002
	BX	LR
 208:	e12fff1e 	bx	lr

0000020c <FiqEnable>:

.global FiqEnable
FiqEnable:
	SWI	SWI_FIQ_EN
 20c:	ef000003 	svc	0x00000003
	BX	LR
 210:	e12fff1e 	bx	lr

00000214 <ClearVector>:

.global ClearVector
ClearVector:
	SWI	SWI_CLR_VECT
 214:	ef000004 	svc	0x00000004
	BX	LR
 218:	e12fff1e 	bx	lr

0000021c <RegisterVector>:

.global RegisterVector
RegisterVector:
	SWI	SWI_REG_VECT
 21c:	ef000005 	svc	0x00000005
	BX	LR
 220:	e12fff1e 	bx	lr

00000224 <StartTask>:
.section .text, "ax"
.arm

.global StartTask
StartTask:
	STR	R1, [R0, #60]		@ Set start address
 224:	e580103c 	str	r1, [r0, #60]	; 0x3c
	STR	R2, [R0, #56]		@ Set stack pointer
 228:	e5802038 	str	r2, [r0, #56]	; 0x38
	MOV	R1, #1			@ Set task state
 22c:	e3a01001 	mov	r1, #1
	STR	R1, [R0]
 230:	e5801000 	str	r1, [r0]
	BX	LR
 234:	e12fff1e 	bx	lr

00000238 <DispatchTask>:

.global DispatchTask
DispatchTask:
	LDR	R1, [R0, #0]		@ Skip if task is absent
 238:	e5901000 	ldr	r1, [r0]
	CMP	R1, #0
 23c:	e3510000 	cmp	r1, #0
	BXEQ	LR
 240:	012fff1e 	bxeq	lr
	LDR	R1, [R0, #4]		@ Skip if task in in sleep state
 244:	e5901004 	ldr	r1, [r0, #4]
	CMP	R1, #0
 248:	e3510000 	cmp	r1, #0
	BXNE	LR
 24c:	112fff1e 	bxne	lr

	STMFD	SP!, {R4-R11,LR}	@ Save current state
 250:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
	LDR	IP, =CurrentTask
 254:	e59fc174 	ldr	ip, [pc, #372]	; 3d0 <sb_align+0x40>
	STR	R0, [IP]
 258:	e58c0000 	str	r0, [ip]
	STR	SP, [IP, #4]
 25c:	e58cd004 	str	sp, [ip, #4]
	ADD	R0, R0, #24		@ Load working regs
 260:	e2800018 	add	r0, r0, #24
	LDMFD	R0!, {R4-R11,SP,LR}
 264:	e8b06ff0 	ldm	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, sp, lr}
	BX	LR			@ Continue task
 268:	e12fff1e 	bx	lr

0000026c <Sleep>:

.global Sleep
Sleep:
	LDR	IP, =CurrentTask	@ Get current task object
 26c:	e59fc15c 	ldr	ip, [pc, #348]	; 3d0 <sb_align+0x40>
	LDR	R1, [IP]
 270:	e59c1000 	ldr	r1, [ip]
	STR	R0, [R1, #4]		@ Set task sleep timer
 274:	e5810004 	str	r0, [r1, #4]
	ADD	R0, R1, #64		@ Save working regs
 278:	e2810040 	add	r0, r1, #64	; 0x40
	STMFD	R0!, {R4-R11,SP,LR}
 27c:	e9206ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, sp, lr}
	LDR	SP, [IP, #4]		@ Rerurn to manager
 280:	e59cd004 	ldr	sp, [ip, #4]
	LDMFD	SP!, {R4-R11,LR}
 284:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
	BX	LR
 288:	e12fff1e 	bx	lr

0000028c <Load_Block>:
@-----------------------------------------------------------@

.global Load_Block
.arm
Load_Block:
	STMFD	SP!, {R4-R8}
 28c:	e92d01f0 	push	{r4, r5, r6, r7, r8}
	ANDS	IP, R1, #3
 290:	e211c003 	ands	ip, r1, #3
	BEQ	lb_align
 294:	0a000012 	beq	2e4 <lb_align>

	BIC	R1, #3
 298:	e3c11003 	bic	r1, r1, #3
	MOV	IP, IP, LSL #3
 29c:	e1a0c18c 	lsl	ip, ip, #3
	RSB	R8, IP, #32
 2a0:	e26c8020 	rsb	r8, ip, #32
	LDMIA	R1!, {R7}
 2a4:	e8b10080 	ldm	r1!, {r7}

000002a8 <lb_l1>:
lb_l1:	MOV	R3, R7
 2a8:	e1a03007 	mov	r3, r7
	LDMIA	R1!, {R4-R7}
 2ac:	e8b100f0 	ldm	r1!, {r4, r5, r6, r7}
	MOV	R3, R3, LSR IP
 2b0:	e1a03c33 	lsr	r3, r3, ip
	ORR	R3, R3, R4, LSL R8
 2b4:	e1833814 	orr	r3, r3, r4, lsl r8
	MOV	R4, R4, LSR IP
 2b8:	e1a04c34 	lsr	r4, r4, ip
	ORR	R4, R4, R5, LSL R8
 2bc:	e1844815 	orr	r4, r4, r5, lsl r8
	MOV	R5, R5, LSR IP
 2c0:	e1a05c35 	lsr	r5, r5, ip
	ORR	R5, R5, R6, LSL R8
 2c4:	e1855816 	orr	r5, r5, r6, lsl r8
	MOV	R6, R6, LSR IP
 2c8:	e1a06c36 	lsr	r6, r6, ip
	ORR	R6, R6, R7, LSL R8
 2cc:	e1866817 	orr	r6, r6, r7, lsl r8
	SUBS	R2, R2, #16
 2d0:	e2522010 	subs	r2, r2, #16
	STMIA	R0!, {R3-R6}
 2d4:	e8a00078 	stmia	r0!, {r3, r4, r5, r6}
	BNE	lb_l1
 2d8:	1afffff2 	bne	2a8 <lb_l1>
	LDMFD	SP!, {R4-R8}
 2dc:	e8bd01f0 	pop	{r4, r5, r6, r7, r8}
	BX	LR
 2e0:	e12fff1e 	bx	lr

000002e4 <lb_align>:

lb_align:
	LDMIA	R1!, {R3-R6}
 2e4:	e8b10078 	ldm	r1!, {r3, r4, r5, r6}
	SUBS	R2, R2, #16
 2e8:	e2522010 	subs	r2, r2, #16
	STMIA	R0!, {R3-R6}
 2ec:	e8a00078 	stmia	r0!, {r3, r4, r5, r6}
	BNE	lb_align
 2f0:	1afffffb 	bne	2e4 <lb_align>
	LDMFD	SP!, {R4-R8}
 2f4:	e8bd01f0 	pop	{r4, r5, r6, r7, r8}
	BX	LR
 2f8:	e12fff1e 	bx	lr

000002fc <Store_Block>:


.global Store_Block
.arm
Store_Block:
	STMFD	SP!, {R4-R8}
 2fc:	e92d01f0 	push	{r4, r5, r6, r7, r8}
	ANDS	IP, R0, #3
 300:	e210c003 	ands	ip, r0, #3
	BEQ	sb_align
 304:	0a000021 	beq	390 <sb_align>

	MOV	IP, IP, LSL #3
 308:	e1a0c18c 	lsl	ip, ip, #3
	RSB	R8, IP, #32
 30c:	e26c8020 	rsb	r8, ip, #32

	LDMIA	R1!, {R4-R7}
 310:	e8b100f0 	ldm	r1!, {r4, r5, r6, r7}

00000314 <sb_p1>:
sb_p1:	STRB	R4, [R0], #1
 314:	e4c04001 	strb	r4, [r0], #1
	MOV	R4, R4, LSR #8
 318:	e1a04424 	lsr	r4, r4, #8
	TST	R0, #3
 31c:	e3100003 	tst	r0, #3
	BNE	sb_p1
 320:	1afffffb 	bne	314 <sb_p1>
	ORR	R4, R4, R5, LSL IP
 324:	e1844c15 	orr	r4, r4, r5, lsl ip
	MOV	R5, R5, LSR R8
 328:	e1a05835 	lsr	r5, r5, r8
	ORR	R5, R5, R6, LSL IP
 32c:	e1855c16 	orr	r5, r5, r6, lsl ip
	MOV	R6, R6, LSR R8
 330:	e1a06836 	lsr	r6, r6, r8
	ORR	R6, R6, R7, LSL IP
 334:	e1866c17 	orr	r6, r6, r7, lsl ip
	SUBS	R2, R2, #16
 338:	e2522010 	subs	r2, r2, #16
	STMIA	R0!, {R4-R6}
 33c:	e8a00070 	stmia	r0!, {r4, r5, r6}

00000340 <sb_l1>:

sb_l1:	MOV	R3, R7
 340:	e1a03007 	mov	r3, r7
	LDMIA	R1!, {R4-R7}
 344:	e8b100f0 	ldm	r1!, {r4, r5, r6, r7}
	MOV	R3, R3, LSR R8
 348:	e1a03833 	lsr	r3, r3, r8
	ORR	R3, R3, R4, LSL IP
 34c:	e1833c14 	orr	r3, r3, r4, lsl ip
	MOV	R4, R4, LSR R8
 350:	e1a04834 	lsr	r4, r4, r8
	ORR	R4, R4, R5, LSL IP
 354:	e1844c15 	orr	r4, r4, r5, lsl ip
	MOV	R5, R5, LSR R8
 358:	e1a05835 	lsr	r5, r5, r8
	ORR	R5, R5, R6, LSL IP
 35c:	e1855c16 	orr	r5, r5, r6, lsl ip
	MOV	R6, R6, LSR R8
 360:	e1a06836 	lsr	r6, r6, r8
	ORR	R6, R6, R7, LSL IP
 364:	e1866c17 	orr	r6, r6, r7, lsl ip
	SUBS	R2, R2, #16
 368:	e2522010 	subs	r2, r2, #16
	STMIA	R0!, {R3-R6}
 36c:	e8a00078 	stmia	r0!, {r3, r4, r5, r6}
	BNE	sb_l1
 370:	1afffff2 	bne	340 <sb_l1>

	MOV	R7, R7, LSR R8
 374:	e1a07837 	lsr	r7, r7, r8

00000378 <sb_p2>:
sb_p2:	SUBS	IP, IP, #8
 378:	e25cc008 	subs	ip, ip, #8
	STRB	R7, [R0], #1
 37c:	e4c07001 	strb	r7, [r0], #1
	MOV	R7, R7, LSR #8
 380:	e1a07427 	lsr	r7, r7, #8
	BNE	sb_p2
 384:	1afffffb 	bne	378 <sb_p2>

	LDMFD	SP!, {R4-R8}
 388:	e8bd01f0 	pop	{r4, r5, r6, r7, r8}
	BX	LR
 38c:	e12fff1e 	bx	lr

00000390 <sb_align>:

sb_align:
	LDMIA	R1!, {R3-R6}
 390:	e8b10078 	ldm	r1!, {r3, r4, r5, r6}
	SUBS	R2, #16
 394:	e2522010 	subs	r2, r2, #16
	STMIA	R0!, {R3-R6}
 398:	e8a00078 	stmia	r0!, {r3, r4, r5, r6}
	BNE	sb_align
 39c:	1afffffb 	bne	390 <sb_align>
	LDMFD	SP!, {R4-R8}
 3a0:	e8bd01f0 	pop	{r4, r5, r6, r7, r8}
	BX	LR
 3a4:	e12fff1e 	bx	lr
 3a8:	40000a18 	.word	0x40000a18
 3ac:	00000d28 	.word	0x00000d28
 3b0:	40000000 	.word	0x40000000
 3b4:	40000000 	.word	0x40000000
 3b8:	40000000 	.word	0x40000000
 3bc:	40000018 	.word	0x40000018
 3c0:	00000648 	.word	0x00000648
 3c4:	fffff000 	.word	0xfffff000
 3c8:	fffff100 	.word	0xfffff100
 3cc:	fffff200 	.word	0xfffff200
 3d0:	40000000 	.word	0x40000000

000003d4 <CPU_Initialize>:
void CPU_Initialize(void)
{
	/*** PLLクロック発振初期化 ***/

	/* すでにPLLが動作中だった場合は停止させる */
	if ( PLLSTAT & (1<<25) ) {
 3d4:	e59f30c4 	ldr	r3, [pc, #196]	; 4a0 <CPU_Initialize+0xcc>
 3d8:	e5932088 	ldr	r2, [r3, #136]	; 0x88
 3dc:	e3120402 	tst	r2, #33554432	; 0x2000000
 3e0:	0a000005 	beq	3fc <CPU_Initialize+0x28>
		/* PLLCON - PLL Enable & disconnected */
		PLLCON   =0x00000001;
 3e4:	e3a02001 	mov	r2, #1
 3e8:	e5832080 	str	r2, [r3, #128]	; 0x80
		/* PLL Feed operation */
		PLLFEED  =0x000000AA;
 3ec:	e28220a9 	add	r2, r2, #169	; 0xa9
 3f0:	e583208c 	str	r2, [r3, #140]	; 0x8c
		PLLFEED  =0x00000055;
 3f4:	e3a02055 	mov	r2, #85	; 0x55
 3f8:	e583208c 	str	r2, [r3, #140]	; 0x8c
	}
	/* PLLCON - PLL Disable & disconnected*/
	PLLCON   =0x00000000;
 3fc:	e3a02000 	mov	r2, #0
 400:	e5832080 	str	r2, [r3, #128]	; 0x80
	/* PLL Feed operation */
	PLLFEED  =0x000000AA;
 404:	e28220aa 	add	r2, r2, #170	; 0xaa
 408:	e583208c 	str	r2, [r3, #140]	; 0x8c
	PLLFEED  =0x00000055;
 40c:	e3a02055 	mov	r2, #85	; 0x55
 410:	e583208c 	str	r2, [r3, #140]	; 0x8c

	SCS = 0x21;	/* 12MHz OSC Enable & FGPIO Select */
 414:	e3a02021 	mov	r2, #33	; 0x21
 418:	e58321a0 	str	r2, [r3, #416]	; 0x1a0
	while((SCS&0x40) == 0){}	/* OSCSTAT Wait */
 41c:	e59f307c 	ldr	r3, [pc, #124]	; 4a0 <CPU_Initialize+0xcc>
 420:	e59321a0 	ldr	r2, [r3, #416]	; 0x1a0
 424:	e3120040 	tst	r2, #64	; 0x40
 428:	0afffffb 	beq	41c <CPU_Initialize+0x48>

	/* CLKSRCSEL - MASTER oscillator select */
	CLKSRCSEL=0x00000001;

	/* PLLCFG - MCLK=12MHz use, FCC0 = 288MHz M=144,N=12 */
	PLLCFG   =0x000B008F;
 42c:	e59f2070 	ldr	r2, [pc, #112]	; 4a4 <CPU_Initialize+0xd0>

	SCS = 0x21;	/* 12MHz OSC Enable & FGPIO Select */
	while((SCS&0x40) == 0){}	/* OSCSTAT Wait */

	/* CLKSRCSEL - MASTER oscillator select */
	CLKSRCSEL=0x00000001;
 430:	e3a00001 	mov	r0, #1
 434:	e583010c 	str	r0, [r3, #268]	; 0x10c

	/* PLLCFG - MCLK=12MHz use, FCC0 = 288MHz M=144,N=12 */
	PLLCFG   =0x000B008F;
	/* PLL Feed operation. */
	PLLFEED  =0x000000AA;
 438:	e3a010aa 	mov	r1, #170	; 0xaa

	/* CLKSRCSEL - MASTER oscillator select */
	CLKSRCSEL=0x00000001;

	/* PLLCFG - MCLK=12MHz use, FCC0 = 288MHz M=144,N=12 */
	PLLCFG   =0x000B008F;
 43c:	e5832084 	str	r2, [r3, #132]	; 0x84
	/* PLL Feed operation. */
	PLLFEED  =0x000000AA;
	PLLFEED  =0x00000055;
 440:	e3a02055 	mov	r2, #85	; 0x55
	CLKSRCSEL=0x00000001;

	/* PLLCFG - MCLK=12MHz use, FCC0 = 288MHz M=144,N=12 */
	PLLCFG   =0x000B008F;
	/* PLL Feed operation. */
	PLLFEED  =0x000000AA;
 444:	e583108c 	str	r1, [r3, #140]	; 0x8c
	PLLFEED  =0x00000055;
 448:	e583208c 	str	r2, [r3, #140]	; 0x8c

	/* PLLCON - PLL Enable & disconnected */
	PLLCON   =0x00000001;
 44c:	e5830080 	str	r0, [r3, #128]	; 0x80
	/* PLL Feed operation */
	PLLFEED  =0x000000AA;
 450:	e583108c 	str	r1, [r3, #140]	; 0x8c
	PLLFEED  =0x00000055;
 454:	e583208c 	str	r2, [r3, #140]	; 0x8c

	/* CPU Clock Divider 1/4 */
	CCLKCFG  =0x00000003;
 458:	e3a02003 	mov	r2, #3
 45c:	e5832104 	str	r2, [r3, #260]	; 0x104
	/* USB Clock Divider 1/6 */
	USBCLKCFG=0x00000005;
 460:	e2822002 	add	r2, r2, #2
 464:	e5832108 	str	r2, [r3, #264]	; 0x108

	while ( ((PLLSTAT & (1<<26)) == 0) ); /* Check lock bit status */
 468:	e59f3030 	ldr	r3, [pc, #48]	; 4a0 <CPU_Initialize+0xcc>
 46c:	e5932088 	ldr	r2, [r3, #136]	; 0x88
 470:	e3120301 	tst	r2, #67108864	; 0x4000000
 474:	0afffffb 	beq	468 <CPU_Initialize+0x94>

	/* PLLCON - PLL Enable & Connected */
	PLLCON   =0x00000003;
 478:	e3a02003 	mov	r2, #3
 47c:	e5832080 	str	r2, [r3, #128]	; 0x80
	/* PLL Feed operation. */
	PLLFEED  =0x000000AA;
 480:	e28220a7 	add	r2, r2, #167	; 0xa7
 484:	e583208c 	str	r2, [r3, #140]	; 0x8c
	PLLFEED  =0x00000055;
 488:	e3a02055 	mov	r2, #85	; 0x55
 48c:	e583208c 	str	r2, [r3, #140]	; 0x8c
	while ( ((PLLSTAT & (1<<25)) == 0) ); /* Check connect bit status */
 490:	e5932088 	ldr	r2, [r3, #136]	; 0x88
 494:	e3120402 	tst	r2, #33554432	; 0x2000000
 498:	0afffffc 	beq	490 <CPU_Initialize+0xbc>
}
 49c:	e12fff1e 	bx	lr
 4a0:	e01fc000 	.word	0xe01fc000
 4a4:	000b008f 	.word	0x000b008f

000004a8 <Delay>:


void Delay(volatile unsigned long nCount)
{
 4a8:	e24dd008 	sub	sp, sp, #8
 4ac:	e58d0004 	str	r0, [sp, #4]
	for(; nCount != 0; nCount--);
 4b0:	ea000002 	b	4c0 <Delay+0x18>
 4b4:	e59d3004 	ldr	r3, [sp, #4]
 4b8:	e2433001 	sub	r3, r3, #1
 4bc:	e58d3004 	str	r3, [sp, #4]
 4c0:	e59d3004 	ldr	r3, [sp, #4]
 4c4:	e3530000 	cmp	r3, #0
 4c8:	1afffff9 	bne	4b4 <Delay+0xc>
}
 4cc:	e28dd008 	add	sp, sp, #8
 4d0:	e12fff1e 	bx	lr

000004d4 <issrgetbit>:
{
	int ret;
	static int bit;
	static int twel = 0;
	static int state = 0;
	if(state){
 4d4:	e59f2090 	ldr	r2, [pc, #144]	; 56c <issrgetbit+0x98>
{
	for(; nCount != 0; nCount--);
}

int issrgetbit(void)
{
 4d8:	e92d4038 	push	{r3, r4, r5, lr}
	int ret;
	static int bit;
	static int twel = 0;
	static int state = 0;
	if(state){
 4dc:	e5925000 	ldr	r5, [r2]
 4e0:	e3550000 	cmp	r5, #0
 4e4:	e59f4084 	ldr	r4, [pc, #132]	; 570 <issrgetbit+0x9c>
 4e8:	e3a03001 	mov	r3, #1
 4ec:	0a00000e 	beq	52c <issrgetbit+0x58>
		state = 0;
 4f0:	e3a01000 	mov	r1, #0
 4f4:	e5821000 	str	r1, [r2]
		FIO2SET0 = 1;
		Delay(10);
 4f8:	e3a0000a 	mov	r0, #10
	static int bit;
	static int twel = 0;
	static int state = 0;
	if(state){
		state = 0;
		FIO2SET0 = 1;
 4fc:	e54430a7 	strb	r3, [r4, #-167]	; 0xffffff59
		Delay(10);
 500:	ebffffe8 	bl	4a8 <Delay>
		bit = (FIO2PIN0 & 3)>>1;
 504:	e55420ab 	ldrb	r2, [r4, #-171]	; 0xffffff55
 508:	e59f3064 	ldr	r3, [pc, #100]	; 574 <issrgetbit+0xa0>
 50c:	e2022003 	and	r2, r2, #3
 510:	e1a020c2 	asr	r2, r2, #1
 514:	e5832000 	str	r2, [r3]
		twel = (twel << 1) | bit;
 518:	e59f3058 	ldr	r3, [pc, #88]	; 578 <issrgetbit+0xa4>
 51c:	e5931000 	ldr	r1, [r3]
 520:	e1822081 	orr	r2, r2, r1, lsl #1
 524:	e5832000 	str	r2, [r3]
 528:	ea00000c 	b	560 <issrgetbit+0x8c>
		ret = -1;
	}
	else {
		state = 1;
 52c:	e5823000 	str	r3, [r2]
		FIO2CLR0 = 1;
		Delay(10);
 530:	e3a0000a 	mov	r0, #10
		twel = (twel << 1) | bit;
		ret = -1;
	}
	else {
		state = 1;
		FIO2CLR0 = 1;
 534:	e54430a3 	strb	r3, [r4, #-163]	; 0xffffff5d
		Delay(10);
 538:	ebffffda 	bl	4a8 <Delay>
		if (bit == ((FIO2PIN0 & 3)>>1))
 53c:	e59f3030 	ldr	r3, [pc, #48]	; 574 <issrgetbit+0xa0>
 540:	e55420ab 	ldrb	r2, [r4, #-171]	; 0xffffff55
 544:	e5933000 	ldr	r3, [r3]
 548:	e2022003 	and	r2, r2, #3
 54c:	e15300a2 	cmp	r3, r2, lsr #1
			ret = -1;
		else {
			ret = twel;
 550:	159f3020 	ldrne	r3, [pc, #32]	; 578 <issrgetbit+0xa4>
 554:	15930000 	ldrne	r0, [r3]
			twel = 0;
 558:	15835000 	strne	r5, [r3]
 55c:	1a000000 	bne	564 <issrgetbit+0x90>
	else {
		state = 1;
		FIO2CLR0 = 1;
		Delay(10);
		if (bit == ((FIO2PIN0 & 3)>>1))
			ret = -1;
 560:	e3e00000 	mvn	r0, #0
			ret = twel;
			twel = 0;
		}
	}
	return ret;
}
 564:	e8bd4038 	pop	{r3, r4, r5, lr}
 568:	e12fff1e 	bx	lr
 56c:	4000000c 	.word	0x4000000c
 570:	3fffc0ff 	.word	0x3fffc0ff
 574:	40000010 	.word	0x40000010
 578:	40000008 	.word	0x40000008

0000057c <Isr_TIMER0>:
/* IRQ 割り込み処理 */
void Isr_TIMER0 (void)
{
 57c:	e92d4008 	push	{r3, lr}
	int twel;
	FIO1PIN ^=0x00040000;
 580:	e59f302c 	ldr	r3, [pc, #44]	; 5b4 <Isr_TIMER0+0x38>
 584:	e5132fcb 	ldr	r2, [r3, #-4043]	; 0xfffff035
 588:	e2222701 	eor	r2, r2, #262144	; 0x40000
 58c:	e5032fcb 	str	r2, [r3, #-4043]	; 0xfffff035
	twel = issrgetbit();
 590:	ebffffcf 	bl	4d4 <issrgetbit>
	if ( twel != -1)
 594:	e3700001 	cmn	r0, #1
		ymzwrite0(twel,0);
 598:	13a01000 	movne	r1, #0
 59c:	1b00013a 	blne	a8c <ymzwrite0>
	T0IR = 1;
 5a0:	e59f3010 	ldr	r3, [pc, #16]	; 5b8 <Isr_TIMER0+0x3c>
 5a4:	e3a02001 	mov	r2, #1
 5a8:	e5832000 	str	r2, [r3]
}
 5ac:	e8bd4008 	pop	{r3, lr}
 5b0:	e12fff1e 	bx	lr
 5b4:	3fffcfff 	.word	0x3fffcfff
 5b8:	e0004000 	.word	0xe0004000

000005bc <ymzinit>:

void ymzinit(void)
{
 5bc:	e92d4008 	push	{r3, lr}
	ymzwrite1(0xfe,7);
 5c0:	e3a000fe 	mov	r0, #254	; 0xfe
 5c4:	e3a01007 	mov	r1, #7
 5c8:	eb000148 	bl	af0 <ymzwrite1>
	ymzwrite1(0xF,0x8);
 5cc:	e3a0000f 	mov	r0, #15
 5d0:	e3a01008 	mov	r1, #8
 5d4:	eb000145 	bl	af0 <ymzwrite1>
	ymzwrite1(0xFe,0x7);
 5d8:	e3a000fe 	mov	r0, #254	; 0xfe
 5dc:	e3a01007 	mov	r1, #7
 5e0:	eb000142 	bl	af0 <ymzwrite1>
}
 5e4:	e8bd4008 	pop	{r3, lr}
 5e8:	e12fff1e 	bx	lr

000005ec <fiqregist>:
void fiqregist(void)
{
 5ec:	e92d4010 	push	{r4, lr}
	/* Use IRQ instead of FIQ */
	VICIntSelect = 0;

	T0PR = 0x00000000;
 5f0:	e59f4048 	ldr	r4, [pc, #72]	; 640 <fiqregist+0x54>
	ymzwrite1(0xFe,0x7);
}
void fiqregist(void)
{
	/* Use IRQ instead of FIQ */
	VICIntSelect = 0;
 5f4:	e3a03000 	mov	r3, #0
 5f8:	e3e02000 	mvn	r2, #0

	T0PR = 0x00000000;
	/*  *TIMER0_MatchRegister0       = 0x00080000; */
	T0MR0 = 0x00010000;
 5fc:	e3a01801 	mov	r1, #65536	; 0x10000
	ymzwrite1(0xFe,0x7);
}
void fiqregist(void)
{
	/* Use IRQ instead of FIQ */
	VICIntSelect = 0;
 600:	e5023ff3 	str	r3, [r2, #-4083]	; 0xfffff00d

	T0PR = 0x00000000;
 604:	e584300c 	str	r3, [r4, #12]
	/*  *TIMER0_MatchRegister0       = 0x00080000; */
	T0MR0 = 0x00010000;
 608:	e5841018 	str	r1, [r4, #24]
	T0MCR = 0x00000003;      /* Match時にTCクリア & 割り込み */
 60c:	e3a01003 	mov	r1, #3
 610:	e5841014 	str	r1, [r4, #20]
	VICIntEnable = TIMER0_INT_BIT;
 614:	e281100d 	add	r1, r1, #13
 618:	e5021fef 	str	r1, [r2, #-4079]	; 0xfffff011

	RegisterVector(TIMER0_INT, Isr_TIMER0, PRI_LOWEST, CLASS_IRQ);
 61c:	e3a00004 	mov	r0, #4
 620:	e59f101c 	ldr	r1, [pc, #28]	; 644 <fiqregist+0x58>
 624:	e2822010 	add	r2, r2, #16
 628:	ebfffefb 	bl	21c <RegisterVector>
	IrqEnable();
 62c:	ebfffef2 	bl	1fc <IrqEnable>

	T0TCR = 1;
 630:	e3a03001 	mov	r3, #1
 634:	e5843004 	str	r3, [r4, #4]
}
 638:	e8bd4010 	pop	{r4, lr}
 63c:	e12fff1e 	bx	lr
 640:	e0004000 	.word	0xe0004000
 644:	0000057c 	.word	0x0000057c

00000648 <main>:

int main(void)
{
 648:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	SCS = SCS | 1;
 64c:	e59f5064 	ldr	r5, [pc, #100]	; 6b8 <main+0x70>
 650:	e59531a0 	ldr	r3, [r5, #416]	; 0x1a0
 654:	e3833001 	orr	r3, r3, #1
 658:	e58531a0 	str	r3, [r5, #416]	; 0x1a0

	CPU_Initialize();
 65c:	ebffff5c 	bl	3d4 <CPU_Initialize>
	GPIOResetInit();
	FIO2DIR1 =2;
	FIO1DIR =0x00040000;
 660:	e59f4054 	ldr	r4, [pc, #84]	; 6bc <main+0x74>
int main(void)
{
	SCS = SCS | 1;

	CPU_Initialize();
	GPIOResetInit();
 664:	eb0000d1 	bl	9b0 <GPIOResetInit>
	FIO2DIR1 =2;
 668:	e59f3050 	ldr	r3, [pc, #80]	; 6c0 <main+0x78>
 66c:	e3a02002 	mov	r2, #2
	FIO1DIR =0x00040000;
	FIO1MASK=0x00000000;
 670:	e3a06000 	mov	r6, #0
	SCS = SCS | 1;

	CPU_Initialize();
	GPIOResetInit();
	FIO2DIR1 =2;
	FIO1DIR =0x00040000;
 674:	e3a07701 	mov	r7, #262144	; 0x40000
{
	SCS = SCS | 1;

	CPU_Initialize();
	GPIOResetInit();
	FIO2DIR1 =2;
 678:	e54320be 	strb	r2, [r3, #-190]	; 0xffffff42
	FIO1DIR =0x00040000;
 67c:	e5047fdf 	str	r7, [r4, #-4063]	; 0xfffff021
	FIO1MASK=0x00000000;
 680:	e5046fcf 	str	r6, [r4, #-4047]	; 0xfffff031

	ymzinit();
 684:	ebffffcc 	bl	5bc <ymzinit>
	ymzwrite0(0x6ff,0);
 688:	e59f0034 	ldr	r0, [pc, #52]	; 6c4 <main+0x7c>
 68c:	e1a01006 	mov	r1, r6
 690:	eb0000fd 	bl	a8c <ymzwrite0>
	i2enable();
 694:	eb00000b 	bl	6c8 <i2enable>
	PCONP |= 0x00001000;
 698:	e59530c4 	ldr	r3, [r5, #196]	; 0xc4
 69c:	e3833a01 	orr	r3, r3, #4096	; 0x1000
 6a0:	e58530c4 	str	r3, [r5, #196]	; 0xc4
	FIO1PIN =0x00040000;
 6a4:	e5047fcb 	str	r7, [r4, #-4043]	; 0xfffff035
	vi2c();
 6a8:	eb0000aa 	bl	958 <vi2c>
	FIO1PIN =0x00000000;
 6ac:	e5046fcb 	str	r6, [r4, #-4043]	; 0xfffff035
	fiqregist();
 6b0:	ebffffcd 	bl	5ec <fiqregist>
 6b4:	eafffffe 	b	6b4 <main+0x6c>
 6b8:	e01fc000 	.word	0xe01fc000
 6bc:	3fffcfff 	.word	0x3fffcfff
 6c0:	3fffc0ff 	.word	0x3fffc0ff
 6c4:	000006ff 	.word	0x000006ff

000006c8 <i2enable>:
Problem	:
****************************************************************************/
void
i2enable ()
{
  PINMODE0 = 0x00000000;
 6c8:	e59f3008 	ldr	r3, [pc, #8]	; 6d8 <i2enable+0x10>
 6cc:	e3a02000 	mov	r2, #0
 6d0:	e5832040 	str	r2, [r3, #64]	; 0x40
}
 6d4:	e12fff1e 	bx	lr
 6d8:	e002c000 	.word	0xe002c000

000006dc <i2cmasterset>:
discribe	:the i2c periphrals which given number will be master
****************************************************************************/
int
i2cmasterset (int a)
{
  switch (a)
 6dc:	e3500001 	cmp	r0, #1
 6e0:	0a000007 	beq	704 <i2cmasterset+0x28>
 6e4:	e3500002 	cmp	r0, #2
 6e8:	0a000008 	beq	710 <i2cmasterset+0x34>
 6ec:	e3500000 	cmp	r0, #0
 6f0:	1a00000b 	bne	724 <i2cmasterset+0x48>
    {
    case 0:
      I20CONSET = 0x40;
 6f4:	e59f3030 	ldr	r3, [pc, #48]	; 72c <i2cmasterset+0x50>
 6f8:	e3a02040 	mov	r2, #64	; 0x40
 6fc:	e5832000 	str	r2, [r3]
      return 0;
 700:	e12fff1e 	bx	lr
      break;
    case 1:
      I21CONSET = 0x40;
 704:	e3a02040 	mov	r2, #64	; 0x40
 708:	e59f3020 	ldr	r3, [pc, #32]	; 730 <i2cmasterset+0x54>
 70c:	ea000001 	b	718 <i2cmasterset+0x3c>
      return 0;
      break;
    case 2:
      I22CONSET = 0x40;
 710:	e59f301c 	ldr	r3, [pc, #28]	; 734 <i2cmasterset+0x58>
 714:	e3a02040 	mov	r2, #64	; 0x40
 718:	e5832000 	str	r2, [r3]
      return 0;
 71c:	e3a00000 	mov	r0, #0
 720:	e12fff1e 	bx	lr
      break;
    default:
      return 1;
 724:	e3a00001 	mov	r0, #1
    }
}
 728:	e12fff1e 	bx	lr
 72c:	e001c000 	.word	0xe001c000
 730:	e005c000 	.word	0xe005c000
 734:	e0080000 	.word	0xe0080000

00000738 <i2cstart>:
discribe	:the i2c will start
****************************************************************************/
int
i2cstart (int a)
{
  switch (a)
 738:	e3500001 	cmp	r0, #1
 73c:	0a00000a 	beq	76c <i2cstart+0x34>
 740:	e3500002 	cmp	r0, #2
 744:	0a00000f 	beq	788 <i2cstart+0x50>
 748:	e3500000 	cmp	r0, #0
 74c:	1a000015 	bne	7a8 <i2cstart+0x70>
    {
    case 0:
      I20CONSET = 0x60;
 750:	e59f3058 	ldr	r3, [pc, #88]	; 7b0 <i2cstart+0x78>
 754:	e3a02060 	mov	r2, #96	; 0x60
 758:	e5832000 	str	r2, [r3]
      while (I20STAT != 0x08);
 75c:	e5932004 	ldr	r2, [r3, #4]
 760:	e3520008 	cmp	r2, #8
 764:	1afffffc 	bne	75c <i2cstart+0x24>
 768:	ea00000c 	b	7a0 <i2cstart+0x68>
      return 0;
      break;
    case 1:
      I21CONSET = 0x60;
 76c:	e59f3040 	ldr	r3, [pc, #64]	; 7b4 <i2cstart+0x7c>
 770:	e3a02060 	mov	r2, #96	; 0x60
 774:	e5832000 	str	r2, [r3]
      while (I21STAT != 0x08);
 778:	e5932004 	ldr	r2, [r3, #4]
 77c:	e3520008 	cmp	r2, #8
 780:	1afffffc 	bne	778 <i2cstart+0x40>
 784:	ea000005 	b	7a0 <i2cstart+0x68>
      return 0;
      break;
    case 2:
      I22CONSET = 0x60;
 788:	e59f3028 	ldr	r3, [pc, #40]	; 7b8 <i2cstart+0x80>
 78c:	e3a02060 	mov	r2, #96	; 0x60
 790:	e5832000 	str	r2, [r3]
      while (I22STAT != 0x08);
 794:	e5932004 	ldr	r2, [r3, #4]
 798:	e3520008 	cmp	r2, #8
 79c:	1afffffc 	bne	794 <i2cstart+0x5c>
      return 0;
 7a0:	e3a00000 	mov	r0, #0
 7a4:	e12fff1e 	bx	lr
      break;
    default:
      return 1;
 7a8:	e3a00001 	mov	r0, #1
    }
}
 7ac:	e12fff1e 	bx	lr
 7b0:	e001c000 	.word	0xe001c000
 7b4:	e005c000 	.word	0xe005c000
 7b8:	e0080000 	.word	0xe0080000

000007bc <i2cstop>:
discribe	:the i2c will stop
****************************************************************************/
void
i2cstop (int a)
{
      I22CONSET = 0x50;
 7bc:	e59f3010 	ldr	r3, [pc, #16]	; 7d4 <i2cstop+0x18>
 7c0:	e3a02050 	mov	r2, #80	; 0x50
 7c4:	e5832000 	str	r2, [r3]
      I22CONCLR = 0x2C;
 7c8:	e3a0202c 	mov	r2, #44	; 0x2c
 7cc:	e5832018 	str	r2, [r3, #24]
}
 7d0:	e12fff1e 	bx	lr
 7d4:	e0080000 	.word	0xe0080000

000007d8 <i2csender>:


void
i2csender (int Continue, unsigned int Data, int size)
{
  if (Continue == 0)
 7d8:	e3500000 	cmp	r0, #0
 7dc:	1a000020 	bne	864 <USR_Stack_Size+0x64>
    {
      I22DAT = Data;
 7e0:	e59f3088 	ldr	r3, [pc, #136]	; 870 <USR_Stack_Size+0x70>
 7e4:	e5831008 	str	r1, [r3, #8]
      I22CONSET |= 0x04;
 7e8:	e5932000 	ldr	r2, [r3]
 7ec:	e3822004 	orr	r2, r2, #4
 7f0:	e5832000 	str	r2, [r3]
      I22CONCLR = 0x08;
 7f4:	e3a02008 	mov	r2, #8
 7f8:	e5832018 	str	r2, [r3, #24]
 7fc:	e59f3070 	ldr	r3, [pc, #112]	; 874 <USR_Stack_Size+0x74>
 800:	e5933000 	ldr	r3, [r3]
      while (I22STAT != 0x18 && I22STAT != 0x20)
 804:	ea000002 	b	814 <USR_Stack_Size+0x14>
      if (I22STAT == 0x20)
 808:	e5922004 	ldr	r2, [r2, #4]
	{
	  i2cErr = 0x22;
 80c:	e3520020 	cmp	r2, #32
 810:	03a03022 	moveq	r3, #34	; 0x22
  if (Continue == 0)
    {
      I22DAT = Data;
      I22CONSET |= 0x04;
      I22CONCLR = 0x08;
      while (I22STAT != 0x18 && I22STAT != 0x20)
 814:	e59f2054 	ldr	r2, [pc, #84]	; 870 <USR_Stack_Size+0x70>
 818:	e5921004 	ldr	r1, [r2, #4]
 81c:	e3510018 	cmp	r1, #24
 820:	0a000002 	beq	830 <USR_Stack_Size+0x30>
 824:	e5921004 	ldr	r1, [r2, #4]
 828:	e3510020 	cmp	r1, #32
 82c:	1afffff5 	bne	808 <USR_Stack_Size+0x8>
 830:	e59f203c 	ldr	r2, [pc, #60]	; 874 <USR_Stack_Size+0x74>
 834:	e5823000 	str	r3, [r2]
 838:	e12fff1e 	bx	lr
    }
  else
    {
      for (; size != 0; size -= 8)
	{
	  I22DAT = (Data & 0xFF);
 83c:	e59f302c 	ldr	r3, [pc, #44]	; 870 <USR_Stack_Size+0x70>
 840:	e20100ff 	and	r0, r1, #255	; 0xff
 844:	e5830008 	str	r0, [r3, #8]
	  I22CONCLR = 0x28;
 848:	e3a00028 	mov	r0, #40	; 0x28
 84c:	e5830018 	str	r0, [r3, #24]
	  while (I22STAT != 0x28);
 850:	e5930004 	ldr	r0, [r3, #4]
 854:	e3500028 	cmp	r0, #40	; 0x28
 858:	1afffffc 	bne	850 <USR_Stack_Size+0x50>
	  Data = Data >> 8;
 85c:	e1a01421 	lsr	r1, r1, #8
	  i2cErr = 0x22;
	}
    }
  else
    {
      for (; size != 0; size -= 8)
 860:	e2422008 	sub	r2, r2, #8
 864:	e3520000 	cmp	r2, #0
 868:	1afffff3 	bne	83c <USR_Stack_Size+0x3c>
 86c:	e12fff1e 	bx	lr
 870:	e0080000 	.word	0xe0080000
 874:	40000014 	.word	0x40000014

00000878 <SCCBwrite>:
    }
}

int
SCCBwrite (int subadr, int size, int Data)
{
 878:	e92d45f8 	push	{r3, r4, r5, r6, r7, r8, sl, lr}
 87c:	e1a0a000 	mov	sl, r0
  i2cstart (2);
 880:	e3a00002 	mov	r0, #2
    }
}

int
SCCBwrite (int subadr, int size, int Data)
{
 884:	e1a07001 	mov	r7, r1
 888:	e1a08002 	mov	r8, r2
  i2cstart (2);
 88c:	ebffffa9 	bl	738 <i2cstart>
//      vTaskDelay(1 / portTICK_RATE_MS);
  FIO2CLR1=2; 
 890:	e59f3070 	ldr	r3, [pc, #112]	; 908 <SCCBwrite+0x90>
  i2cErr = 0;
 894:	e59f6070 	ldr	r6, [pc, #112]	; 90c <SCCBwrite+0x94>
 898:	e3a04000 	mov	r4, #0
int
SCCBwrite (int subadr, int size, int Data)
{
  i2cstart (2);
//      vTaskDelay(1 / portTICK_RATE_MS);
  FIO2CLR1=2; 
 89c:	e3a05002 	mov	r5, #2
 8a0:	e54350a2 	strb	r5, [r3, #-162]	; 0xffffff5e
  i2cErr = 0;
  i2csender (0, 0x42, 8);
 8a4:	e1a00004 	mov	r0, r4
 8a8:	e3a01042 	mov	r1, #66	; 0x42
 8ac:	e3a02008 	mov	r2, #8
SCCBwrite (int subadr, int size, int Data)
{
  i2cstart (2);
//      vTaskDelay(1 / portTICK_RATE_MS);
  FIO2CLR1=2; 
  i2cErr = 0;
 8b0:	e5864000 	str	r4, [r6]
  i2csender (0, 0x42, 8);
 8b4:	ebffffc7 	bl	7d8 <i2csender>
  if (i2cErr == 0x22)
 8b8:	e5963000 	ldr	r3, [r6]
 8bc:	e3530022 	cmp	r3, #34	; 0x22
 8c0:	1a000003 	bne	8d4 <SCCBwrite+0x5c>
    {
      i2cstop (2);
 8c4:	e1a00005 	mov	r0, r5
 8c8:	ebffffbb 	bl	7bc <i2cstop>
      return -1;
 8cc:	e3e00000 	mvn	r0, #0
 8d0:	ea00000a 	b	900 <SCCBwrite+0x88>
    }
  i2csender (1, subadr, 8);	//3byte? 
 8d4:	e3a00001 	mov	r0, #1
 8d8:	e1a0100a 	mov	r1, sl
 8dc:	e3a02008 	mov	r2, #8
 8e0:	ebffffbc 	bl	7d8 <i2csender>
  i2csender (1, Data, size);
 8e4:	e3a00001 	mov	r0, #1
 8e8:	e1a01008 	mov	r1, r8
 8ec:	e1a02007 	mov	r2, r7
 8f0:	ebffffb8 	bl	7d8 <i2csender>
  i2cstop (2);
 8f4:	e1a00005 	mov	r0, r5
 8f8:	ebffffaf 	bl	7bc <i2cstop>
  return 0;
 8fc:	e1a00004 	mov	r0, r4
}
 900:	e8bd45f8 	pop	{r3, r4, r5, r6, r7, r8, sl, lr}
 904:	e12fff1e 	bx	lr
 908:	3fffc0ff 	.word	0x3fffc0ff
 90c:	40000014 	.word	0x40000014

00000910 <SCCBByteWrite>:

int
SCCBByteWrite (int inp)
{
 910:	e92d4038 	push	{r3, r4, r5, lr}
	int ret;
      FIO2PIN1 =0;
 914:	e59f4038 	ldr	r4, [pc, #56]	; 954 <SCCBByteWrite+0x44>
 918:	e3a03000 	mov	r3, #0
  return 0;
}

int
SCCBByteWrite (int inp)
{
 91c:	e1a05000 	mov	r5, r0
	int ret;
      FIO2PIN1 =0;
 920:	e54430aa 	strb	r3, [r4, #-170]	; 0xffffff56
    Delay(100);
 924:	e3a00064 	mov	r0, #100	; 0x64
 928:	ebfffede 	bl	4a8 <Delay>
	ret = SCCBwrite ((inp >> 8 & 0xFF), 8, (inp & 0xFF)) ;
 92c:	e1a00425 	lsr	r0, r5, #8
 930:	e20520ff 	and	r2, r5, #255	; 0xff
 934:	e3a01008 	mov	r1, #8
 938:	e20000ff 	and	r0, r0, #255	; 0xff
 93c:	ebffffcd 	bl	878 <SCCBwrite>
      if(ret==-1)FIO2PIN1 =2;
 940:	e3700001 	cmn	r0, #1
 944:	03a03002 	moveq	r3, #2
 948:	054430aa 	strbeq	r3, [r4, #-170]	; 0xffffff56
	return ret;
}
 94c:	e8bd4038 	pop	{r3, r4, r5, lr}
 950:	e12fff1e 	bx	lr
 954:	3fffc0ff 	.word	0x3fffc0ff

00000958 <vi2c>:
void
vi2c (void)
{
 958:	e92d4010 	push	{r4, lr}
  int regpointer = 0;
  char Loopy;
  i2cmasterset (2);
 95c:	e3a00002 	mov	r0, #2
 960:	ebffff5d 	bl	6dc <i2cmasterset>
  I22SCLH = 80;
 964:	e59f303c 	ldr	r3, [pc, #60]	; 9a8 <vi2c+0x50>
 968:	e3a02050 	mov	r2, #80	; 0x50
 96c:	e5832010 	str	r2, [r3, #16]
  I22SCLL = 180;
 970:	e2822064 	add	r2, r2, #100	; 0x64
 974:	e5832014 	str	r2, [r3, #20]
  for (regpointer = 0; regpointer != 129;)
 978:	e3a04000 	mov	r4, #0
    {
    Delay(100);
 97c:	e3a00064 	mov	r0, #100	; 0x64
 980:	ebfffec8 	bl	4a8 <Delay>
      if (SCCBByteWrite (OV7670[regpointer]) == -1) continue;
 984:	e59f3020 	ldr	r3, [pc, #32]	; 9ac <vi2c+0x54>
 988:	e7930104 	ldr	r0, [r3, r4, lsl #2]
 98c:	ebffffdf 	bl	910 <SCCBByteWrite>
 990:	e3700001 	cmn	r0, #1
      regpointer++;
 994:	12844001 	addne	r4, r4, #1
  int regpointer = 0;
  char Loopy;
  i2cmasterset (2);
  I22SCLH = 80;
  I22SCLL = 180;
  for (regpointer = 0; regpointer != 129;)
 998:	e3540081 	cmp	r4, #129	; 0x81
 99c:	1afffff6 	bne	97c <vi2c+0x24>
    {
    Delay(100);
      if (SCCBByteWrite (OV7670[regpointer]) == -1) continue;
      regpointer++;
    }
}
 9a0:	e8bd4010 	pop	{r4, lr}
 9a4:	e12fff1e 	bx	lr
 9a8:	e0080000 	.word	0xe0080000
 9ac:	00000b24 	.word	0x00000b24

000009b0 <GPIOResetInit>:
** 
******************************************************************************/
void GPIOResetInit( void )
{
	/* Reset all GPIO pins to default: primary function */
    PINSEL0 = 0x0FA00050;
 9b0:	e59f20c0 	ldr	r2, [pc, #192]	; a78 <Stack_Size+0x78>
 9b4:	e59f30c0 	ldr	r3, [pc, #192]	; a7c <Stack_Size+0x7c>
 9b8:	e5823000 	str	r3, [r2]
    PINSEL1 = 0x00154000;
 9bc:	e3a03955 	mov	r3, #1392640	; 0x154000
 9c0:	e5823004 	str	r3, [r2, #4]
    PINSEL2 = 0x00000000;
    PINSEL3 = 0xF0000000;
 9c4:	e3a0120f 	mov	r1, #-268435456	; 0xf0000000
void GPIOResetInit( void )
{
	/* Reset all GPIO pins to default: primary function */
    PINSEL0 = 0x0FA00050;
    PINSEL1 = 0x00154000;
    PINSEL2 = 0x00000000;
 9c8:	e2433955 	sub	r3, r3, #1392640	; 0x154000
 9cc:	e5823008 	str	r3, [r2, #8]
    PINSEL3 = 0xF0000000;
 9d0:	e582100c 	str	r1, [r2, #12]
    PINSEL4 = 0x00000000;
 9d4:	e5823010 	str	r3, [r2, #16]
    PINSEL5 = 0x00000000;
 9d8:	e5823014 	str	r3, [r2, #20]
    PINSEL6 = 0x00000000;
 9dc:	e5823018 	str	r3, [r2, #24]
    PINSEL7 = 0x00000000;
 9e0:	e582301c 	str	r3, [r2, #28]
    PINSEL8 = 0x00000000;
 9e4:	e5823020 	str	r3, [r2, #32]
    PINSEL9 = 0x00000000;
 9e8:	e5823024 	str	r3, [r2, #36]	; 0x24
   PINSEL10 = 0x00000000;
 9ec:	e5823028 	str	r3, [r2, #40]	; 0x28
    
     IODIR0 = 0x00000000;
 9f0:	e2422901 	sub	r2, r2, #16384	; 0x4000
 9f4:	e5823008 	str	r3, [r2, #8]
     IOSET0 = 0x00000000;
     IOSET1 = 0x00000000;
    
    FIO0DIR = 0x00000000;
    FIO1DIR = 0x00000000;
    FIO2DIR = 0x00000201;
 9f8:	e59f1080 	ldr	r1, [pc, #128]	; a80 <Stack_Size+0x80>
    PINSEL8 = 0x00000000;
    PINSEL9 = 0x00000000;
   PINSEL10 = 0x00000000;
    
     IODIR0 = 0x00000000;
     IODIR1 = 0x00000000;
 9fc:	e5823018 	str	r3, [r2, #24]
     IOSET0 = 0x00000000;
 a00:	e5823004 	str	r3, [r2, #4]
     IOSET1 = 0x00000000;
 a04:	e5823014 	str	r3, [r2, #20]
    
    FIO0DIR = 0x00000000;
 a08:	e59f2074 	ldr	r2, [pc, #116]	; a84 <Stack_Size+0x84>
 a0c:	e5023fff 	str	r3, [r2, #-4095]	; 0xfffff001
    FIO1DIR = 0x00000000;
 a10:	e5023fdf 	str	r3, [r2, #-4063]	; 0xfffff021
    FIO2DIR = 0x00000201;
 a14:	e5021fbf 	str	r1, [r2, #-4031]	; 0xfffff041
    FIO3DIR = 0x00000000;
    FIO4DIR = 0x0000FFFF;
 a18:	e59f1068 	ldr	r1, [pc, #104]	; a88 <Stack_Size+0x88>
     IOSET1 = 0x00000000;
    
    FIO0DIR = 0x00000000;
    FIO1DIR = 0x00000000;
    FIO2DIR = 0x00000201;
    FIO3DIR = 0x00000000;
 a1c:	e5023f9f 	str	r3, [r2, #-3999]	; 0xfffff061
    FIO4DIR = 0x0000FFFF;
 a20:	e5021f7f 	str	r1, [r2, #-3967]	; 0xfffff081
    
	FIO0MASK = 0x00000000;
 a24:	e5023fef 	str	r3, [r2, #-4079]	; 0xfffff011
	FIO0PIN = 0x00000000;
 a28:	e5023feb 	str	r3, [r2, #-4075]	; 0xfffff015
	FIO0SET = 0x00000000;
 a2c:	e5023fe7 	str	r3, [r2, #-4071]	; 0xfffff019
	FIO0CLR = 0x00000000;
 a30:	e5023fe3 	str	r3, [r2, #-4067]	; 0xfffff01d
	
	FIO1MASK = 0x00000000;
 a34:	e5023fcf 	str	r3, [r2, #-4047]	; 0xfffff031
	FIO1PIN = 0x00000000;
 a38:	e5023fcb 	str	r3, [r2, #-4043]	; 0xfffff035
	FIO1SET = 0x00000000;
 a3c:	e5023fc7 	str	r3, [r2, #-4039]	; 0xfffff039
	FIO1CLR = 0x00000000;
 a40:	e5023fc3 	str	r3, [r2, #-4035]	; 0xfffff03d
	
	FIO2MASK = 0x00000000;
 a44:	e5023faf 	str	r3, [r2, #-4015]	; 0xfffff051
	FIO2PIN = 0x00000000;
 a48:	e5023fab 	str	r3, [r2, #-4011]	; 0xfffff055
	FIO2SET = 0x00000000;
 a4c:	e5023fa7 	str	r3, [r2, #-4007]	; 0xfffff059
	FIO2CLR = 0x00000000;
 a50:	e5023fa3 	str	r3, [r2, #-4003]	; 0xfffff05d

	FIO3MASK = 0x00000000;
 a54:	e5023f8f 	str	r3, [r2, #-3983]	; 0xfffff071
	FIO3PIN = 0x00000000;
 a58:	e5023f8b 	str	r3, [r2, #-3979]	; 0xfffff075
	FIO3SET = 0x00000000;
 a5c:	e5023f87 	str	r3, [r2, #-3975]	; 0xfffff079
	FIO3CLR = 0x00000000;
 a60:	e5023f83 	str	r3, [r2, #-3971]	; 0xfffff07d
	
	FIO4MASK = 0x00000000;
 a64:	e5023f6f 	str	r3, [r2, #-3951]	; 0xfffff091
	FIO4PIN = 0x00000000;
 a68:	e5023f6b 	str	r3, [r2, #-3947]	; 0xfffff095
	FIO4SET = 0x00000000;
 a6c:	e5023f67 	str	r3, [r2, #-3943]	; 0xfffff099
	FIO4CLR = 0x00000000;
 a70:	e5023f63 	str	r3, [r2, #-3939]	; 0xfffff09d
	
    return;        
}
 a74:	e12fff1e 	bx	lr
 a78:	e002c000 	.word	0xe002c000
 a7c:	0fa00050 	.word	0x0fa00050
 a80:	00000201 	.word	0x00000201
 a84:	3fffcfff 	.word	0x3fffcfff
 a88:	0000ffff 	.word	0x0000ffff

00000a8c <ymzwrite0>:

int
ymzwrite0 (int frec, int adr)
{
  int highbyte;
  FIO4PIN = 0x00;
 a8c:	e59f3058 	ldr	r3, [pc, #88]	; aec <ymzwrite0+0x60>
 a90:	e3a02000 	mov	r2, #0
 * =====================================================================================
 */

int
ymzwrite0 (int frec, int adr)
{
 a94:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
  int highbyte;
  FIO4PIN = 0x00;
  FIO4PIN = adr;
  FIO4PIN = 0x200 + adr;
  FIO4PIN = 0x100 + (frec & 0xFF);
 a98:	e200c0ff 	and	ip, r0, #255	; 0xff

int
ymzwrite0 (int frec, int adr)
{
  int highbyte;
  FIO4PIN = 0x00;
 a9c:	e5032f6b 	str	r2, [r3, #-3947]	; 0xfffff095
  FIO4PIN = adr;
  FIO4PIN = 0x200 + adr;
 aa0:	e2812c02 	add	r2, r1, #512	; 0x200
int
ymzwrite0 (int frec, int adr)
{
  int highbyte;
  FIO4PIN = 0x00;
  FIO4PIN = adr;
 aa4:	e5031f6b 	str	r1, [r3, #-3947]	; 0xfffff095
  FIO4PIN = 0x200 + adr;
  FIO4PIN = 0x100 + (frec & 0xFF);
 aa8:	e28c4c01 	add	r4, ip, #256	; 0x100
ymzwrite0 (int frec, int adr)
{
  int highbyte;
  FIO4PIN = 0x00;
  FIO4PIN = adr;
  FIO4PIN = 0x200 + adr;
 aac:	e5032f6b 	str	r2, [r3, #-3947]	; 0xfffff095
  FIO4PIN = 0x100 + (frec & 0xFF);
  FIO4PIN = 0x300 + (frec & 0xFF);
 ab0:	e28ccc03 	add	ip, ip, #768	; 0x300
  FIO4PIN = adr + 1;
 ab4:	e2811001 	add	r1, r1, #1
  FIO4PIN = 0x201 + adr;
 ab8:	e2822001 	add	r2, r2, #1
  highbyte = (frec >> 8) & 0xFF;
 abc:	e1a00440 	asr	r0, r0, #8
{
  int highbyte;
  FIO4PIN = 0x00;
  FIO4PIN = adr;
  FIO4PIN = 0x200 + adr;
  FIO4PIN = 0x100 + (frec & 0xFF);
 ac0:	e5034f6b 	str	r4, [r3, #-3947]	; 0xfffff095
  FIO4PIN = 0x300 + (frec & 0xFF);
 ac4:	e503cf6b 	str	ip, [r3, #-3947]	; 0xfffff095
  FIO4PIN = adr + 1;
 ac8:	e5031f6b 	str	r1, [r3, #-3947]	; 0xfffff095
  FIO4PIN = 0x201 + adr;
 acc:	e5032f6b 	str	r2, [r3, #-3947]	; 0xfffff095
  highbyte = (frec >> 8) & 0xFF;
 ad0:	e20020ff 	and	r2, r0, #255	; 0xff
  FIO4PIN = 0x100 + highbyte;
 ad4:	e2822c01 	add	r2, r2, #256	; 0x100
  FIO4PIN = 0x300 + (frec >> 8);
 ad8:	e2800c03 	add	r0, r0, #768	; 0x300
  FIO4PIN = 0x100 + (frec & 0xFF);
  FIO4PIN = 0x300 + (frec & 0xFF);
  FIO4PIN = adr + 1;
  FIO4PIN = 0x201 + adr;
  highbyte = (frec >> 8) & 0xFF;
  FIO4PIN = 0x100 + highbyte;
 adc:	e5032f6b 	str	r2, [r3, #-3947]	; 0xfffff095
  FIO4PIN = 0x300 + (frec >> 8);
 ae0:	e5030f6b 	str	r0, [r3, #-3947]	; 0xfffff095
}
 ae4:	e49d4004 	pop	{r4}		; (ldr r4, [sp], #4)
 ae8:	e12fff1e 	bx	lr
 aec:	3fffcfff 	.word	0x3fffcfff

00000af0 <ymzwrite1>:

int
ymzwrite1 (int value, int adr)
{
  FIO4PIN = 0x00;
 af0:	e59f3028 	ldr	r3, [pc, #40]	; b20 <ymzwrite1+0x30>
 af4:	e3a02000 	mov	r2, #0
 af8:	e5032f6b 	str	r2, [r3, #-3947]	; 0xfffff095
  FIO4PIN = adr;
  FIO4PIN = (0x200 + adr);
 afc:	e2812c02 	add	r2, r1, #512	; 0x200

int
ymzwrite1 (int value, int adr)
{
  FIO4PIN = 0x00;
  FIO4PIN = adr;
 b00:	e5031f6b 	str	r1, [r3, #-3947]	; 0xfffff095
  FIO4PIN = (0x200 + adr);
 b04:	e5032f6b 	str	r2, [r3, #-3947]	; 0xfffff095
  FIO4PIN = (0x100 + value);
 b08:	e2802c01 	add	r2, r0, #256	; 0x100
 b0c:	e5032f6b 	str	r2, [r3, #-3947]	; 0xfffff095
  FIO4PIN = (0x300 + value);
 b10:	e2802c03 	add	r2, r0, #768	; 0x300
 b14:	e5032f6b 	str	r2, [r3, #-3947]	; 0xfffff095
  return adr * 16 + value;
}
 b18:	e0800201 	add	r0, r0, r1, lsl #4
 b1c:	e12fff1e 	bx	lr
 b20:	3fffcfff 	.word	0x3fffcfff

00000b24 <OV7670>:
 b24:	00001204 000040d0 00008c02 0000703a     .....@......:p..
 b34:	00007211 000040d0 00008c02 0000703a     .r...@......:p..
 b44:	00007135 00007211 000073f0 0000a202     5q...r...s......
 b54:	00001500 00007a20 00007b10 00007c1e     .... z...{...|..
 b64:	00007d35 00007e5a 00007f69 00008076     5}..Z~..i...v...
 b74:	00008180 00008288 0000838f 00008496     ................
 b84:	000085a3 000086af 000087c4 000088d7     ................
 b94:	000089e8 000013e0 00000000 00001000     ................
 ba4:	00000d40 00001418 0000a505 0000ab07     @...............
 bb4:	00002495 00002533 000026e3 00009f78     .$..3%...&..x...
 bc4:	0000a068 0000a103 0000a6d8 0000a7d8     h...............
 bd4:	0000a8f0 0000a990 0000aa94 000013e5     ................
 be4:	00000e61 00000f4b 00001602 00001e07     a...K...........
 bf4:	00002102 00002291 00002907 0000330b     .!..."...)...3..
 c04:	0000350b 0000371d 00003871 0000392a     .5...7..q8..*9..
 c14:	00003c78 00004d34 00004e20 00006900     x<..4M.. N...i..
 c24:	00006b0a 00007410 00008d4f 00008e00     .k...t..O.......
 c34:	00008f00 00009000 00009100 00009600     ................
 c44:	00009a00 0000b084 0000b10c 0000b20e     ................
 c54:	0000b382 0000b80a 0000430a 000044f0     .........C...D..
 c64:	00004534 0000483a 00005999 00005a88     4E..:H...Y...Z..
 c74:	00005b44 00005c67 00005d49 00005e0e     D[..g\..I]...^..
 c84:	00006c0a 00006d55 00006e11 00006f9f     .l..Um...n...o..
 c94:	00006a40 00000140 00000260 000013e7     @j..@...`.......
 ca4:	00004f80 00005080 00005100 00005222     .O...P...Q.."R..
 cb4:	0000535e 00005480 0000589e 00004108     ^S...T...X...A..
 cc4:	00003f00 00007505 000076e1 00004c00     .?...u...v...L..
 cd4:	00007701 00003dc3 00004b09 0000c960     .w...=...K..`...
 ce4:	00004138 00005640 00003411 00003b12     8A..@V...4...;..
 cf4:	0000a488 00009600 00009730 00009820     ........0... ...
 d04:	00009930 00009a84 00009b29 00009c03     0.......).......
 d14:	00009d4c 00009e3f 00007804 00007901     L...?....x...y..
 d24:	0000c8f0                                ....
